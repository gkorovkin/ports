Index: webrtc/src/webrtc/base/sigslot.h
===================================================================
--- webrtc.orig/src/webrtc/base/sigslot.h	2017-01-12 16:02:41.901491323 +0300
+++ webrtc/src/webrtc/base/sigslot.h	2017-01-12 16:02:41.898491337 +0300
@@ -90,6 +90,7 @@
 #include <list>
 #include <set>
 #include <stdlib.h>
+#include <string.h>
 
 // On our copy of sigslot.h, we set single threading as default.
 #define SIGSLOT_DEFAULT_MT_POLICY single_threaded
@@ -123,17 +124,9 @@ namespace sigslot {
 	class single_threaded
 	{
 	public:
-		single_threaded()
-		{
-			;
-		}
-
-                virtual ~single_threaded() {}
-
-                virtual void lock() {}
-
-                virtual void unlock() {}
-        };
+		void lock() {}
+		void unlock() {}
+	};
 
 #ifdef _SIGSLOT_HAS_WIN32_THREADS
 	// The multi threading policies only get compiled in if they are enabled.
@@ -151,22 +144,12 @@ namespace sigslot {
 			}
 		}
 
-		multi_threaded_global(const multi_threaded_global&)
-		{
-			;
-		}
-
-		virtual ~multi_threaded_global()
-		{
-			;
-		}
-
-		virtual void lock()
+		void lock()
 		{
 			EnterCriticalSection(get_critsec());
 		}
 
-		virtual void unlock()
+		void unlock()
 		{
 			LeaveCriticalSection(get_critsec());
 		}
@@ -192,17 +175,17 @@ namespace sigslot {
 			InitializeCriticalSection(&m_critsec);
 		}
 
-		virtual ~multi_threaded_local()
+		~multi_threaded_local()
 		{
 			DeleteCriticalSection(&m_critsec);
 		}
 
-		virtual void lock()
+		void lock()
 		{
 			EnterCriticalSection(&m_critsec);
 		}
 
-		virtual void unlock()
+		void unlock()
 		{
 			LeaveCriticalSection(&m_critsec);
 		}
@@ -217,30 +200,44 @@ namespace sigslot {
 	class multi_threaded_global
 	{
 	public:
-         multi_threaded_global();
-         multi_threaded_global(const multi_threaded_global&);
-         virtual ~multi_threaded_global();
-         virtual void lock();
-         virtual void unlock();
-
-        private:
-		pthread_mutex_t* get_mutex()
+		void lock()
+		{
+			pthread_mutex_lock(&g_mutex);
+		}
+		void unlock()
 		{
-			static pthread_mutex_t g_mutex;
-			return &g_mutex;
+			pthread_mutex_unlock(&g_mutex);
 		}
+
+	private:
+		static pthread_mutex_t g_mutex;
 	};
 
 	class multi_threaded_local
 	{
 	public:
-         multi_threaded_local();
-         multi_threaded_local(const multi_threaded_local&);
-         virtual ~multi_threaded_local();
-         virtual void lock();
-         virtual void unlock();
+		multi_threaded_local()
+		{
+			pthread_mutex_init(&m_mutex, NULL);
+		}
+		multi_threaded_local(const multi_threaded_local&)
+		{
+			pthread_mutex_init(&m_mutex, NULL);
+		}
+		~multi_threaded_local()
+		{
+			pthread_mutex_destroy(&m_mutex);
+		}
+		void lock()
+		{
+			pthread_mutex_lock(&m_mutex);
+		}
+		void unlock()
+		{
+			pthread_mutex_unlock(&m_mutex);
+		}
 
-        private:
+	private:
 		pthread_mutex_t m_mutex;
 	};
 #endif // _SIGSLOT_HAS_POSIX_THREADS
@@ -263,2542 +260,712 @@ namespace sigslot {
 		}
 	};
 
-	class has_slots_interface;
-
-	template<class mt_policy>
-	class _connection_base0
-	{
-	public:
-		virtual ~_connection_base0() {}
-		virtual has_slots_interface* getdest() const = 0;
-		virtual void emit() = 0;
-		virtual _connection_base0* clone() = 0;
-		virtual _connection_base0* duplicate(has_slots_interface* pnewdest) = 0;
-	};
-
-	template<class arg1_type, class mt_policy>
-	class _connection_base1
-	{
-	public:
-		virtual ~_connection_base1() {}
-		virtual has_slots_interface* getdest() const = 0;
-		virtual void emit(arg1_type) = 0;
-		virtual _connection_base1<arg1_type, mt_policy>* clone() = 0;
-		virtual _connection_base1<arg1_type, mt_policy>* duplicate(has_slots_interface* pnewdest) = 0;
-	};
-
-	template<class arg1_type, class arg2_type, class mt_policy>
-	class _connection_base2
-	{
-	public:
-		virtual ~_connection_base2() {}
-		virtual has_slots_interface* getdest() const = 0;
-		virtual void emit(arg1_type, arg2_type) = 0;
-		virtual _connection_base2<arg1_type, arg2_type, mt_policy>* clone() = 0;
-		virtual _connection_base2<arg1_type, arg2_type, mt_policy>* duplicate(has_slots_interface* pnewdest) = 0;
-	};
-
-	template<class arg1_type, class arg2_type, class arg3_type, class mt_policy>
-	class _connection_base3
-	{
-	public:
-		virtual ~_connection_base3() {}
-		virtual has_slots_interface* getdest() const = 0;
-		virtual void emit(arg1_type, arg2_type, arg3_type) = 0;
-		virtual _connection_base3<arg1_type, arg2_type, arg3_type, mt_policy>* clone() = 0;
-		virtual _connection_base3<arg1_type, arg2_type, arg3_type, mt_policy>* duplicate(has_slots_interface* pnewdest) = 0;
-	};
-
-	template<class arg1_type, class arg2_type, class arg3_type, class arg4_type, class mt_policy>
-	class _connection_base4
-	{
-	public:
-		virtual ~_connection_base4() {}
-		virtual has_slots_interface* getdest() const = 0;
-		virtual void emit(arg1_type, arg2_type, arg3_type, arg4_type) = 0;
-		virtual _connection_base4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>* clone() = 0;
-		virtual _connection_base4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>* duplicate(has_slots_interface* pnewdest) = 0;
-	};
-
-	template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
-	class arg5_type, class mt_policy>
-	class _connection_base5
-	{
-	public:
-		virtual ~_connection_base5() {}
-		virtual has_slots_interface* getdest() const = 0;
-		virtual void emit(arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type) = 0;
-		virtual _connection_base5<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, mt_policy>* clone() = 0;
-		virtual _connection_base5<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, mt_policy>* duplicate(has_slots_interface* pnewdest) = 0;
-	};
-
-	template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
-	class arg5_type, class arg6_type, class mt_policy>
-	class _connection_base6
-	{
-	public:
-		virtual ~_connection_base6() {}
-		virtual has_slots_interface* getdest() const = 0;
-		virtual void emit(arg1_type, arg2_type, arg3_type, arg4_type, arg5_type,
-			arg6_type) = 0;
-		virtual _connection_base6<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, arg6_type, mt_policy>* clone() = 0;
-		virtual _connection_base6<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, arg6_type, mt_policy>* duplicate(has_slots_interface* pnewdest) = 0;
-	};
-
-	template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
-	class arg5_type, class arg6_type, class arg7_type, class mt_policy>
-	class _connection_base7
-	{
-	public:
-		virtual ~_connection_base7() {}
-		virtual has_slots_interface* getdest() const = 0;
-		virtual void emit(arg1_type, arg2_type, arg3_type, arg4_type, arg5_type,
-			arg6_type, arg7_type) = 0;
-		virtual _connection_base7<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, arg6_type, arg7_type, mt_policy>* clone() = 0;
-		virtual _connection_base7<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, arg6_type, arg7_type, mt_policy>* duplicate(has_slots_interface* pnewdest) = 0;
-	};
-
-	template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
-	class arg5_type, class arg6_type, class arg7_type, class arg8_type, class mt_policy>
-	class _connection_base8
-	{
-	public:
-		virtual ~_connection_base8() {}
-		virtual has_slots_interface* getdest() const = 0;
-		virtual void emit(arg1_type, arg2_type, arg3_type, arg4_type, arg5_type,
-			arg6_type, arg7_type, arg8_type) = 0;
-		virtual _connection_base8<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>* clone() = 0;
-		virtual _connection_base8<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>* duplicate(has_slots_interface* pnewdest) = 0;
-	};
-
-	class _signal_base_interface
-	{
-	public:
-		virtual ~_signal_base_interface() {}
-		virtual void slot_disconnect(has_slots_interface* pslot) = 0;
-		virtual void slot_duplicate(const has_slots_interface* poldslot, has_slots_interface* pnewslot) = 0;
-	};
-
-	template<class mt_policy>
-	class _signal_base : public _signal_base_interface, public mt_policy
-	{
-	};
+	class _signal_base_interface;
 
 	class has_slots_interface
 	{
-	public:
-		has_slots_interface()
-		{
-			;
-		}
-
-		virtual void signal_connect(_signal_base_interface* sender) = 0;
-
-		virtual void signal_disconnect(_signal_base_interface* sender) = 0;
-
-		virtual ~has_slots_interface()
-		{
-		}
-
-		virtual void disconnect_all() = 0;
-	};
-
-	template<class mt_policy = SIGSLOT_DEFAULT_MT_POLICY>
-	class has_slots : public has_slots_interface, public mt_policy
-	{
 	private:
-		typedef std::set<_signal_base_interface*> sender_set;
-		typedef sender_set::const_iterator const_iterator;
+		typedef void (*signal_connect_t)(has_slots_interface* self, _signal_base_interface* sender);
+		typedef void (*signal_disconnect_t)(has_slots_interface* self, _signal_base_interface* sender);
+		typedef void (*disconnect_all_t)(has_slots_interface* self);
+
+		const signal_connect_t m_signal_connect;
+		const signal_disconnect_t m_signal_disconnect;
+		const disconnect_all_t m_disconnect_all;
 
-	public:
-		has_slots()
+	protected:
+		has_slots_interface(signal_connect_t conn, signal_disconnect_t disc, disconnect_all_t disc_all) :
+			m_signal_connect(conn), m_signal_disconnect(disc), m_disconnect_all(disc_all)
 		{
-			;
 		}
 
-		has_slots(const has_slots& hs)
-		{
-			lock_block<mt_policy> lock(this);
-			const_iterator it = hs.m_senders.begin();
-			const_iterator itEnd = hs.m_senders.end();
-
-			while(it != itEnd)
-			{
-				(*it)->slot_duplicate(&hs, this);
-				m_senders.insert(*it);
-				++it;
-			}
-		}
+		~has_slots_interface() {}
 
+	public:
 		void signal_connect(_signal_base_interface* sender)
 		{
-			lock_block<mt_policy> lock(this);
-			m_senders.insert(sender);
+			m_signal_connect(this, sender);
 		}
 
 		void signal_disconnect(_signal_base_interface* sender)
 		{
-			lock_block<mt_policy> lock(this);
-			m_senders.erase(sender);
-		}
-
-		virtual ~has_slots()
-		{
-			disconnect_all();
+			m_signal_disconnect(this, sender);
 		}
 
 		void disconnect_all()
 		{
-			lock_block<mt_policy> lock(this);
-			const_iterator it = m_senders.begin();
-			const_iterator itEnd = m_senders.end();
-
-			while(it != itEnd)
-			{
-				(*it)->slot_disconnect(this);
-				++it;
-			}
-
-			m_senders.erase(m_senders.begin(), m_senders.end());
+			m_disconnect_all(this);
 		}
-
-	private:
-		sender_set m_senders;
 	};
 
-	template<class mt_policy>
-	class _signal_base0 : public _signal_base<mt_policy>
+	class _signal_base_interface
 	{
-	public:
-		typedef std::list<_connection_base0<mt_policy> *>  connections_list;
+	private:
+		typedef void (*slot_disconnect_t)(_signal_base_interface* self, has_slots_interface* pslot);
+		typedef void (*slot_duplicate_t)(_signal_base_interface* self, const has_slots_interface* poldslot, has_slots_interface* pnewslot);
 
-		_signal_base0()
-		{
-			;
-		}
+		const slot_disconnect_t m_slot_disconnect;
+		const slot_duplicate_t m_slot_duplicate;
 
-		_signal_base0(const _signal_base0& s)
-			: _signal_base<mt_policy>(s)
+	protected:
+		_signal_base_interface(slot_disconnect_t disc, slot_duplicate_t dupl) :
+			m_slot_disconnect(disc), m_slot_duplicate(dupl)
 		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = s.m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = s.m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				(*it)->getdest()->signal_connect(this);
-				m_connected_slots.push_back((*it)->clone());
-
-				++it;
-			}
 		}
 
-		~_signal_base0()
+		~_signal_base_interface() {}
+
+	public:
+		void slot_disconnect(has_slots_interface* pslot)
 		{
-			disconnect_all();
+			m_slot_disconnect(this, pslot);
 		}
 
-		bool is_empty()
+		void slot_duplicate(const has_slots_interface* poldslot, has_slots_interface* pnewslot)
 		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-			return it == itEnd;
+			m_slot_duplicate(this, poldslot, pnewslot);
 		}
+	};
 
-		void disconnect_all()
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
+	class _opaque_connection
+	{
+	private:
+		typedef void (_opaque_connection::*method_t)();
+		typedef void (*emit_t)(const _opaque_connection*);
 
-			while(it != itEnd)
-			{
-				(*it)->getdest()->signal_disconnect(this);
-				delete *it;
+		emit_t pemit;
+		has_slots_interface* pdest;
+		method_t pmethod;
 
-				++it;
-			}
+	public:
+		template< typename DestT, typename... Args >
+		_opaque_connection(DestT* pd, void (DestT::*pm)(Args...)) : pdest(pd)
+		{
+			typedef void (DestT::*pm_t)(Args...);
+			static_assert(sizeof(pm_t) == sizeof(method_t), "Unsupported platform: cannot cast member function pointers");
+			memcpy(&pmethod, &pm, sizeof(pm));
 
-			m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
+			typedef void (*em_t)(const _opaque_connection* self, Args...);
+			static_assert(sizeof(em_t) == sizeof(emit_t), "Unsupported platform: cannot cast member function pointers");
+			em_t em = &_opaque_connection::emit_impl< DestT, Args... >;
+			memcpy(&pemit, &em, sizeof(em));
 		}
 
-#if !defined(NDEBUG)
-			bool connected(has_slots_interface* pclass)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-			while(it != itEnd)
-			{
-				itNext = it;
-				++itNext;
-				if ((*it)->getdest() == pclass)
-					return true;
-				it = itNext;
-			}
-			return false;
-		}
-#endif
+		has_slots_interface* getdest() const { return pdest; }
 
-		void disconnect(has_slots_interface* pclass)
+		_opaque_connection duplicate(has_slots_interface* newtarget) const
 		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				if((*it)->getdest() == pclass)
-				{
-					delete *it;
-					m_connected_slots.erase(it);
-					pclass->signal_disconnect(this);
-					return;
-				}
-
-				++it;
-			}
+			_opaque_connection res = *this;
+			res.pdest = newtarget;
+			return res;
 		}
 
-		void slot_disconnect(has_slots_interface* pslot)
+		template< typename... Args >
+		void emit(Args... args) const
 		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				typename connections_list::iterator itNext = it;
-				++itNext;
-
-				if((*it)->getdest() == pslot)
-				{
-					delete *it;
-					m_connected_slots.erase(it);
-				}
-
-				it = itNext;
-			}
+			typedef void (*em_t)(const _opaque_connection* self, Args...);
+			em_t em;
+			memcpy(&em, &pemit, sizeof(em));
+			em(this, args...);
 		}
 
-		void slot_duplicate(const has_slots_interface* oldtarget, has_slots_interface* newtarget)
+	private:
+		template< typename DestT, typename... Args >
+		static void emit_impl(const _opaque_connection* self, Args... args)
 		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				if((*it)->getdest() == oldtarget)
-				{
-					m_connected_slots.push_back((*it)->duplicate(newtarget));
-				}
-
-				++it;
-			}
+			typedef void (DestT::*pm_t)(Args...);
+			pm_t pm;
+			memcpy(&pm, &self->pmethod, sizeof(pm));
+			(static_cast< DestT* >(self->pdest)->*pm)(args...);
 		}
-
-	protected:
-		connections_list m_connected_slots;
 	};
 
-	template<class arg1_type, class mt_policy>
-	class _signal_base1 : public _signal_base<mt_policy>
+	template<class mt_policy>
+	class _signal_base : public _signal_base_interface, public mt_policy
 	{
-	public:
-		typedef std::list<_connection_base1<arg1_type, mt_policy> *>  connections_list;
-
-		_signal_base1()
-		{
-			;
-		}
-
-		_signal_base1(const _signal_base1<arg1_type, mt_policy>& s)
-			: _signal_base<mt_policy>(s)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = s.m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = s.m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				(*it)->getdest()->signal_connect(this);
-				m_connected_slots.push_back((*it)->clone());
-
-				++it;
-			}
-		}
+	protected:
+		typedef std::list< _opaque_connection > connections_list;
 
-		void slot_duplicate(const has_slots_interface* oldtarget, has_slots_interface* newtarget)
+		_signal_base() : _signal_base_interface(&_signal_base::do_slot_disconnect, &_signal_base::do_slot_duplicate)
 		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				if((*it)->getdest() == oldtarget)
-				{
-					m_connected_slots.push_back((*it)->duplicate(newtarget));
-				}
-
-				++it;
-			}
 		}
 
-		~_signal_base1()
+		~_signal_base()
 		{
 			disconnect_all();
 		}
 
+	private:
+		_signal_base(const _signal_base& s);
+		_signal_base& operator= (_signal_base const& that);
+
+	public:
 		bool is_empty()
 		{
 			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-			return it == itEnd;
+			return m_connected_slots.empty();
 		}
 
 		void disconnect_all()
 		{
 			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
 
-			while(it != itEnd)
+			while(!m_connected_slots.empty())
 			{
-				(*it)->getdest()->signal_disconnect(this);
-				delete *it;
-
-				++it;
+				has_slots_interface* pdest = m_connected_slots.front().getdest();
+				m_connected_slots.pop_front();
+				pdest->signal_disconnect(static_cast< _signal_base_interface* >(this));
 			}
-
-			m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
 		}
 
 #if !defined(NDEBUG)
-			bool connected(has_slots_interface* pclass)
+		bool connected(has_slots_interface* pclass)
 		{
 			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
+			connections_list::const_iterator it = m_connected_slots.begin();
+			connections_list::const_iterator itEnd = m_connected_slots.end();
 			while(it != itEnd)
 			{
-				itNext = it;
-				++itNext;
-				if ((*it)->getdest() == pclass)
+				if (it->getdest() == pclass)
 					return true;
-				it = itNext;
-			}
-			return false;
-		}
-#endif
-
-		void disconnect(has_slots_interface* pclass)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				if((*it)->getdest() == pclass)
-				{
-					delete *it;
-					m_connected_slots.erase(it);
-					pclass->signal_disconnect(this);
-					return;
-				}
-
-				++it;
-			}
-		}
-
-		void slot_disconnect(has_slots_interface* pslot)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				typename connections_list::iterator itNext = it;
-				++itNext;
-
-				if((*it)->getdest() == pslot)
-				{
-					delete *it;
-					m_connected_slots.erase(it);
-				}
-
-				it = itNext;
-			}
-		}
-
-
-	protected:
-		connections_list m_connected_slots;
-	};
-
-	template<class arg1_type, class arg2_type, class mt_policy>
-	class _signal_base2 : public _signal_base<mt_policy>
-	{
-	public:
-		typedef std::list<_connection_base2<arg1_type, arg2_type, mt_policy> *>
-			connections_list;
-
-		_signal_base2()
-		{
-			;
-		}
-
-		_signal_base2(const _signal_base2<arg1_type, arg2_type, mt_policy>& s)
-			: _signal_base<mt_policy>(s)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = s.m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = s.m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				(*it)->getdest()->signal_connect(this);
-				m_connected_slots.push_back((*it)->clone());
-
-				++it;
-			}
-		}
-
-		void slot_duplicate(const has_slots_interface* oldtarget, has_slots_interface* newtarget)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				if((*it)->getdest() == oldtarget)
-				{
-					m_connected_slots.push_back((*it)->duplicate(newtarget));
-				}
-
-				++it;
-			}
-		}
-
-		~_signal_base2()
-		{
-			disconnect_all();
-		}
-
-		bool is_empty()
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-			return it == itEnd;
-		}
-
-		void disconnect_all()
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				(*it)->getdest()->signal_disconnect(this);
-				delete *it;
-
-				++it;
-			}
-
-			m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
-		}
-
-#if !defined(NDEBUG)
-			bool connected(has_slots_interface* pclass)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-			while(it != itEnd)
-			{
-				itNext = it;
-				++itNext;
-				if ((*it)->getdest() == pclass)
-					return true;
-				it = itNext;
-			}
-			return false;
-		}
-#endif
-
-		void disconnect(has_slots_interface* pclass)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				if((*it)->getdest() == pclass)
-				{
-					delete *it;
-					m_connected_slots.erase(it);
-					pclass->signal_disconnect(this);
-					return;
-				}
-
-				++it;
-			}
-		}
-
-		void slot_disconnect(has_slots_interface* pslot)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				typename connections_list::iterator itNext = it;
-				++itNext;
-
-				if((*it)->getdest() == pslot)
-				{
-					delete *it;
-					m_connected_slots.erase(it);
-				}
-
-				it = itNext;
-			}
-		}
-
-	protected:
-		connections_list m_connected_slots;
-	};
-
-	template<class arg1_type, class arg2_type, class arg3_type, class mt_policy>
-	class _signal_base3 : public _signal_base<mt_policy>
-	{
-	public:
-		typedef std::list<_connection_base3<arg1_type, arg2_type, arg3_type, mt_policy> *>
-			connections_list;
-
-		_signal_base3()
-		{
-			;
-		}
-
-		_signal_base3(const _signal_base3<arg1_type, arg2_type, arg3_type, mt_policy>& s)
-			: _signal_base<mt_policy>(s)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = s.m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = s.m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				(*it)->getdest()->signal_connect(this);
-				m_connected_slots.push_back((*it)->clone());
-
-				++it;
-			}
-		}
-
-		void slot_duplicate(const has_slots_interface* oldtarget, has_slots_interface* newtarget)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				if((*it)->getdest() == oldtarget)
-				{
-					m_connected_slots.push_back((*it)->duplicate(newtarget));
-				}
-
-				++it;
-			}
-		}
-
-		~_signal_base3()
-		{
-			disconnect_all();
-		}
-
-		bool is_empty()
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-			return it == itEnd;
-		}
-
-		void disconnect_all()
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				(*it)->getdest()->signal_disconnect(this);
-				delete *it;
-
-				++it;
-			}
-
-			m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
-		}
-
-#if !defined(NDEBUG)
-			bool connected(has_slots_interface* pclass)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-			while(it != itEnd)
-			{
-				itNext = it;
-				++itNext;
-				if ((*it)->getdest() == pclass)
-					return true;
-				it = itNext;
-			}
-			return false;
-		}
-#endif
-
-		void disconnect(has_slots_interface* pclass)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				if((*it)->getdest() == pclass)
-				{
-					delete *it;
-					m_connected_slots.erase(it);
-					pclass->signal_disconnect(this);
-					return;
-				}
-
-				++it;
-			}
-		}
-
-		void slot_disconnect(has_slots_interface* pslot)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				typename connections_list::iterator itNext = it;
-				++itNext;
-
-				if((*it)->getdest() == pslot)
-				{
-					delete *it;
-					m_connected_slots.erase(it);
-				}
-
-				it = itNext;
-			}
-		}
-
-	protected:
-		connections_list m_connected_slots;
-	};
-
-	template<class arg1_type, class arg2_type, class arg3_type, class arg4_type, class mt_policy>
-	class _signal_base4 : public _signal_base<mt_policy>
-	{
-	public:
-		typedef std::list<_connection_base4<arg1_type, arg2_type, arg3_type,
-			arg4_type, mt_policy> *>  connections_list;
-
-		_signal_base4()
-		{
-			;
-		}
-
-		_signal_base4(const _signal_base4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>& s)
-			: _signal_base<mt_policy>(s)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = s.m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = s.m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				(*it)->getdest()->signal_connect(this);
-				m_connected_slots.push_back((*it)->clone());
-
-				++it;
-			}
-		}
-
-		void slot_duplicate(const has_slots_interface* oldtarget, has_slots_interface* newtarget)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				if((*it)->getdest() == oldtarget)
-				{
-					m_connected_slots.push_back((*it)->duplicate(newtarget));
-				}
-
-				++it;
-			}
-		}
-
-		~_signal_base4()
-		{
-			disconnect_all();
-		}
-
-		bool is_empty()
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-			return it == itEnd;
-		}
-
-		void disconnect_all()
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				(*it)->getdest()->signal_disconnect(this);
-				delete *it;
-
-				++it;
-			}
-
-			m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
-		}
-
-#if !defined(NDEBUG)
-			bool connected(has_slots_interface* pclass)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-			while(it != itEnd)
-			{
-				itNext = it;
-				++itNext;
-				if ((*it)->getdest() == pclass)
-					return true;
-				it = itNext;
-			}
-			return false;
-		}
-#endif
-
-		void disconnect(has_slots_interface* pclass)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				if((*it)->getdest() == pclass)
-				{
-					delete *it;
-					m_connected_slots.erase(it);
-					pclass->signal_disconnect(this);
-					return;
-				}
-
-				++it;
-			}
-		}
-
-		void slot_disconnect(has_slots_interface* pslot)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				typename connections_list::iterator itNext = it;
-				++itNext;
-
-				if((*it)->getdest() == pslot)
-				{
-					delete *it;
-					m_connected_slots.erase(it);
-				}
-
-				it = itNext;
-			}
-		}
-
-	protected:
-		connections_list m_connected_slots;
-	};
-
-	template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
-	class arg5_type, class mt_policy>
-	class _signal_base5 : public _signal_base<mt_policy>
-	{
-	public:
-		typedef std::list<_connection_base5<arg1_type, arg2_type, arg3_type,
-			arg4_type, arg5_type, mt_policy> *>  connections_list;
-
-		_signal_base5()
-		{
-			;
-		}
-
-		_signal_base5(const _signal_base5<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, mt_policy>& s)
-			: _signal_base<mt_policy>(s)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = s.m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = s.m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				(*it)->getdest()->signal_connect(this);
-				m_connected_slots.push_back((*it)->clone());
-
-				++it;
-			}
-		}
-
-		void slot_duplicate(const has_slots_interface* oldtarget, has_slots_interface* newtarget)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				if((*it)->getdest() == oldtarget)
-				{
-					m_connected_slots.push_back((*it)->duplicate(newtarget));
-				}
-
-				++it;
-			}
-		}
-
-		~_signal_base5()
-		{
-			disconnect_all();
-		}
-
-		bool is_empty()
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-			return it == itEnd;
-		}
-
-		void disconnect_all()
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				(*it)->getdest()->signal_disconnect(this);
-				delete *it;
-
-				++it;
-			}
-
-			m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
-		}
-
-#if !defined(NDEBUG)
-			bool connected(has_slots_interface* pclass)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-			while(it != itEnd)
-			{
-				itNext = it;
-				++itNext;
-				if ((*it)->getdest() == pclass)
-					return true;
-				it = itNext;
-			}
-			return false;
-		}
-#endif
-
-		void disconnect(has_slots_interface* pclass)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				if((*it)->getdest() == pclass)
-				{
-					delete *it;
-					m_connected_slots.erase(it);
-					pclass->signal_disconnect(this);
-					return;
-				}
-
-				++it;
-			}
-		}
-
-		void slot_disconnect(has_slots_interface* pslot)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				typename connections_list::iterator itNext = it;
-				++itNext;
-
-				if((*it)->getdest() == pslot)
-				{
-					delete *it;
-					m_connected_slots.erase(it);
-				}
-
-				it = itNext;
-			}
-		}
-
-	protected:
-		connections_list m_connected_slots;
-	};
-
-	template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
-	class arg5_type, class arg6_type, class mt_policy>
-	class _signal_base6 : public _signal_base<mt_policy>
-	{
-	public:
-		typedef std::list<_connection_base6<arg1_type, arg2_type, arg3_type,
-			arg4_type, arg5_type, arg6_type, mt_policy> *>  connections_list;
-
-		_signal_base6()
-		{
-			;
-		}
-
-		_signal_base6(const _signal_base6<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, arg6_type, mt_policy>& s)
-			: _signal_base<mt_policy>(s)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = s.m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = s.m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				(*it)->getdest()->signal_connect(this);
-				m_connected_slots.push_back((*it)->clone());
-
-				++it;
-			}
-		}
-
-		void slot_duplicate(const has_slots_interface* oldtarget, has_slots_interface* newtarget)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				if((*it)->getdest() == oldtarget)
-				{
-					m_connected_slots.push_back((*it)->duplicate(newtarget));
-				}
-
-				++it;
-			}
-		}
-
-		~_signal_base6()
-		{
-			disconnect_all();
-		}
-
-		bool is_empty()
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-			return it == itEnd;
-		}
-
-		void disconnect_all()
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				(*it)->getdest()->signal_disconnect(this);
-				delete *it;
-
-				++it;
-			}
-
-			m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
-		}
-
-#if !defined(NDEBUG)
-			bool connected(has_slots_interface* pclass)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-			while(it != itEnd)
-			{
-				itNext = it;
-				++itNext;
-				if ((*it)->getdest() == pclass)
-					return true;
-				it = itNext;
-			}
-			return false;
-		}
-#endif
-
-		void disconnect(has_slots_interface* pclass)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				if((*it)->getdest() == pclass)
-				{
-					delete *it;
-					m_connected_slots.erase(it);
-					pclass->signal_disconnect(this);
-					return;
-				}
-
-				++it;
-			}
-		}
-
-		void slot_disconnect(has_slots_interface* pslot)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				typename connections_list::iterator itNext = it;
-				++itNext;
-
-				if((*it)->getdest() == pslot)
-				{
-					delete *it;
-					m_connected_slots.erase(it);
-				}
-
-				it = itNext;
-			}
-		}
-
-	protected:
-		connections_list m_connected_slots;
-	};
-
-	template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
-	class arg5_type, class arg6_type, class arg7_type, class mt_policy>
-	class _signal_base7 : public _signal_base<mt_policy>
-	{
-	public:
-		typedef std::list<_connection_base7<arg1_type, arg2_type, arg3_type,
-			arg4_type, arg5_type, arg6_type, arg7_type, mt_policy> *>  connections_list;
-
-		_signal_base7()
-		{
-			;
-		}
-
-		_signal_base7(const _signal_base7<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, arg6_type, arg7_type, mt_policy>& s)
-			: _signal_base<mt_policy>(s)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = s.m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = s.m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				(*it)->getdest()->signal_connect(this);
-				m_connected_slots.push_back((*it)->clone());
-
-				++it;
-			}
-		}
-
-		void slot_duplicate(const has_slots_interface* oldtarget, has_slots_interface* newtarget)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				if((*it)->getdest() == oldtarget)
-				{
-					m_connected_slots.push_back((*it)->duplicate(newtarget));
-				}
-
-				++it;
-			}
-		}
-
-		~_signal_base7()
-		{
-			disconnect_all();
-		}
-
-		bool is_empty()
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-			return it == itEnd;
-		}
-
-		void disconnect_all()
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				(*it)->getdest()->signal_disconnect(this);
-				delete *it;
-
-				++it;
-			}
-
-			m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
-		}
-
-#if !defined(NDEBUG)
-			bool connected(has_slots_interface* pclass)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-			while(it != itEnd)
-			{
-				itNext = it;
-				++itNext;
-				if ((*it)->getdest() == pclass)
-					return true;
-				it = itNext;
-			}
-			return false;
-		}
-#endif
-
-		void disconnect(has_slots_interface* pclass)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				if((*it)->getdest() == pclass)
-				{
-					delete *it;
-					m_connected_slots.erase(it);
-					pclass->signal_disconnect(this);
-					return;
-				}
-
-				++it;
-			}
-		}
-
-		void slot_disconnect(has_slots_interface* pslot)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				typename connections_list::iterator itNext = it;
-				++itNext;
-
-				if((*it)->getdest() == pslot)
-				{
-					delete *it;
-					m_connected_slots.erase(it);
-				}
-
-				it = itNext;
-			}
-		}
-
-	protected:
-		connections_list m_connected_slots;
-	};
-
-	template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
-	class arg5_type, class arg6_type, class arg7_type, class arg8_type, class mt_policy>
-	class _signal_base8 : public _signal_base<mt_policy>
-	{
-	public:
-		typedef std::list<_connection_base8<arg1_type, arg2_type, arg3_type,
-			arg4_type, arg5_type, arg6_type, arg7_type, arg8_type, mt_policy> *>
-			connections_list;
-
-		_signal_base8()
-		{
-			;
-		}
-
-		_signal_base8(const _signal_base8<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>& s)
-			: _signal_base<mt_policy>(s)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = s.m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = s.m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				(*it)->getdest()->signal_connect(this);
-				m_connected_slots.push_back((*it)->clone());
-
-				++it;
-			}
-		}
-
-		void slot_duplicate(const has_slots_interface* oldtarget, has_slots_interface* newtarget)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				if((*it)->getdest() == oldtarget)
-				{
-					m_connected_slots.push_back((*it)->duplicate(newtarget));
-				}
-
-				++it;
-			}
-		}
-
-		~_signal_base8()
-		{
-			disconnect_all();
-		}
-
-		bool is_empty()
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-			return it == itEnd;
-		}
-
-		void disconnect_all()
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				(*it)->getdest()->signal_disconnect(this);
-				delete *it;
-
-				++it;
-			}
-
-			m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
-		}
-
-#if !defined(NDEBUG)
-			bool connected(has_slots_interface* pclass)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-			while(it != itEnd)
-			{
-				itNext = it;
-				++itNext;
-				if ((*it)->getdest() == pclass)
-					return true;
-				it = itNext;
-			}
-			return false;
-		}
-#endif
-
-		void disconnect(has_slots_interface* pclass)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				if((*it)->getdest() == pclass)
-				{
-					delete *it;
-					m_connected_slots.erase(it);
-					pclass->signal_disconnect(this);
-					return;
-				}
-
-				++it;
-			}
-		}
-
-		void slot_disconnect(has_slots_interface* pslot)
-		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::iterator it = m_connected_slots.begin();
-			typename connections_list::iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				typename connections_list::iterator itNext = it;
-				++itNext;
-
-				if((*it)->getdest() == pslot)
-				{
-					delete *it;
-					m_connected_slots.erase(it);
-				}
-
-				it = itNext;
-			}
-		}
-
-	protected:
-		connections_list m_connected_slots;
-	};
-
-
-	template<class dest_type, class mt_policy>
-	class _connection0 : public _connection_base0<mt_policy>
-	{
-	public:
-		_connection0()
-		{
-			m_pobject = NULL;
-			m_pmemfun = NULL;
-		}
-
-		_connection0(dest_type* pobject, void (dest_type::*pmemfun)())
-		{
-			m_pobject = pobject;
-			m_pmemfun = pmemfun;
-		}
-
-		virtual ~_connection0()
-		{
-                }
-
-		virtual _connection_base0<mt_policy>* clone()
-		{
-			return new _connection0<dest_type, mt_policy>(*this);
-		}
-
-		virtual _connection_base0<mt_policy>* duplicate(has_slots_interface* pnewdest)
-		{
-			return new _connection0<dest_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
-		}
-
-		virtual void emit()
-		{
-			(m_pobject->*m_pmemfun)();
-		}
-
-		virtual has_slots_interface* getdest() const
-		{
-			return m_pobject;
-		}
-
-	private:
-		dest_type* m_pobject;
-		void (dest_type::* m_pmemfun)();
-	};
-
-	template<class dest_type, class arg1_type, class mt_policy>
-	class _connection1 : public _connection_base1<arg1_type, mt_policy>
-	{
-	public:
-		_connection1()
-		{
-			m_pobject = NULL;
-			m_pmemfun = NULL;
-		}
-
-		_connection1(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type))
-		{
-			m_pobject = pobject;
-			m_pmemfun = pmemfun;
-		}
-
-		virtual ~_connection1()
-		{
-                }
-
-		virtual _connection_base1<arg1_type, mt_policy>* clone()
-		{
-			return new _connection1<dest_type, arg1_type, mt_policy>(*this);
-		}
-
-		virtual _connection_base1<arg1_type, mt_policy>* duplicate(has_slots_interface* pnewdest)
-		{
-			return new _connection1<dest_type, arg1_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
-		}
-
-		virtual void emit(arg1_type a1)
-		{
-			(m_pobject->*m_pmemfun)(a1);
-		}
-
-		virtual has_slots_interface* getdest() const
-		{
-			return m_pobject;
-		}
-
-	private:
-		dest_type* m_pobject;
-		void (dest_type::* m_pmemfun)(arg1_type);
-	};
-
-	template<class dest_type, class arg1_type, class arg2_type, class mt_policy>
-	class _connection2 : public _connection_base2<arg1_type, arg2_type, mt_policy>
-	{
-	public:
-		_connection2()
-		{
-			m_pobject = NULL;
-			m_pmemfun = NULL;
-		}
-
-		_connection2(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
-			arg2_type))
-		{
-			m_pobject = pobject;
-			m_pmemfun = pmemfun;
-		}
-
-		virtual ~_connection2()
-		{
-                }
-
-		virtual _connection_base2<arg1_type, arg2_type, mt_policy>* clone()
-		{
-			return new _connection2<dest_type, arg1_type, arg2_type, mt_policy>(*this);
-		}
-
-		virtual _connection_base2<arg1_type, arg2_type, mt_policy>* duplicate(has_slots_interface* pnewdest)
-		{
-			return new _connection2<dest_type, arg1_type, arg2_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
-		}
-
-		virtual void emit(arg1_type a1, arg2_type a2)
-		{
-			(m_pobject->*m_pmemfun)(a1, a2);
-		}
-
-		virtual has_slots_interface* getdest() const
-		{
-			return m_pobject;
-		}
-
-	private:
-		dest_type* m_pobject;
-		void (dest_type::* m_pmemfun)(arg1_type, arg2_type);
-	};
-
-	template<class dest_type, class arg1_type, class arg2_type, class arg3_type, class mt_policy>
-	class _connection3 : public _connection_base3<arg1_type, arg2_type, arg3_type, mt_policy>
-	{
-	public:
-		_connection3()
-		{
-			m_pobject = NULL;
-			m_pmemfun = NULL;
-		}
-
-		_connection3(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
-			arg2_type, arg3_type))
-		{
-			m_pobject = pobject;
-			m_pmemfun = pmemfun;
-		}
-
-		virtual ~_connection3()
-		{
-                }
-
-		virtual _connection_base3<arg1_type, arg2_type, arg3_type, mt_policy>* clone()
-		{
-			return new _connection3<dest_type, arg1_type, arg2_type, arg3_type, mt_policy>(*this);
-		}
-
-		virtual _connection_base3<arg1_type, arg2_type, arg3_type, mt_policy>* duplicate(has_slots_interface* pnewdest)
-		{
-			return new _connection3<dest_type, arg1_type, arg2_type, arg3_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
-		}
-
-		virtual void emit(arg1_type a1, arg2_type a2, arg3_type a3)
-		{
-			(m_pobject->*m_pmemfun)(a1, a2, a3);
-		}
-
-		virtual has_slots_interface* getdest() const
-		{
-			return m_pobject;
-		}
-
-	private:
-		dest_type* m_pobject;
-		void (dest_type::* m_pmemfun)(arg1_type, arg2_type, arg3_type);
-	};
-
-	template<class dest_type, class arg1_type, class arg2_type, class arg3_type,
-	class arg4_type, class mt_policy>
-	class _connection4 : public _connection_base4<arg1_type, arg2_type,
-		arg3_type, arg4_type, mt_policy>
-	{
-	public:
-		_connection4()
-		{
-			m_pobject = NULL;
-			m_pmemfun = NULL;
-		}
-
-		_connection4(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
-			arg2_type, arg3_type, arg4_type))
-		{
-			m_pobject = pobject;
-			m_pmemfun = pmemfun;
-		}
-
-		virtual ~_connection4()
-		{
-                }
-
-		virtual _connection_base4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>* clone()
-		{
-			return new _connection4<dest_type, arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>(*this);
-		}
-
-		virtual _connection_base4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>* duplicate(has_slots_interface* pnewdest)
-		{
-			return new _connection4<dest_type, arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
-		}
-
-		virtual void emit(arg1_type a1, arg2_type a2, arg3_type a3,
-			arg4_type a4)
-		{
-			(m_pobject->*m_pmemfun)(a1, a2, a3, a4);
-		}
-
-		virtual has_slots_interface* getdest() const
-		{
-			return m_pobject;
-		}
-
-	private:
-		dest_type* m_pobject;
-		void (dest_type::* m_pmemfun)(arg1_type, arg2_type, arg3_type,
-			arg4_type);
-	};
-
-	template<class dest_type, class arg1_type, class arg2_type, class arg3_type,
-	class arg4_type, class arg5_type, class mt_policy>
-	class _connection5 : public _connection_base5<arg1_type, arg2_type,
-		arg3_type, arg4_type, arg5_type, mt_policy>
-	{
-	public:
-		_connection5()
-		{
-			m_pobject = NULL;
-			m_pmemfun = NULL;
-		}
-
-		_connection5(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
-			arg2_type, arg3_type, arg4_type, arg5_type))
-		{
-			m_pobject = pobject;
-			m_pmemfun = pmemfun;
-		}
-
-		virtual ~_connection5()
-		{
-                }
-
-		virtual _connection_base5<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, mt_policy>* clone()
-		{
-			return new _connection5<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
-				arg5_type, mt_policy>(*this);
-		}
-
-		virtual _connection_base5<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, mt_policy>* duplicate(has_slots_interface* pnewdest)
-		{
-			return new _connection5<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
-				arg5_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
-		}
-
-		virtual void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
-			arg5_type a5)
-		{
-			(m_pobject->*m_pmemfun)(a1, a2, a3, a4, a5);
-		}
-
-		virtual has_slots_interface* getdest() const
-		{
-			return m_pobject;
-		}
-
-	private:
-		dest_type* m_pobject;
-		void (dest_type::* m_pmemfun)(arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type);
-	};
-
-	template<class dest_type, class arg1_type, class arg2_type, class arg3_type,
-	class arg4_type, class arg5_type, class arg6_type, class mt_policy>
-	class _connection6 : public _connection_base6<arg1_type, arg2_type,
-		arg3_type, arg4_type, arg5_type, arg6_type, mt_policy>
-	{
-	public:
-		_connection6()
-		{
-			m_pobject = NULL;
-			m_pmemfun = NULL;
-		}
-
-		_connection6(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
-			arg2_type, arg3_type, arg4_type, arg5_type, arg6_type))
-		{
-			m_pobject = pobject;
-			m_pmemfun = pmemfun;
-		}
-
-		virtual ~_connection6()
-		{
-                }
-
-		virtual _connection_base6<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, arg6_type, mt_policy>* clone()
-		{
-			return new _connection6<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
-				arg5_type, arg6_type, mt_policy>(*this);
+				++it;
+			}
+			return false;
 		}
+#endif
 
-		virtual _connection_base6<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, arg6_type, mt_policy>* duplicate(has_slots_interface* pnewdest)
+		void disconnect(has_slots_interface* pclass)
 		{
-			return new _connection6<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
-				arg5_type, arg6_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
-		}
+			lock_block<mt_policy> lock(this);
+			connections_list::iterator it = m_connected_slots.begin();
+			connections_list::iterator itEnd = m_connected_slots.end();
 
-		virtual void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
-			arg5_type a5, arg6_type a6)
-		{
-			(m_pobject->*m_pmemfun)(a1, a2, a3, a4, a5, a6);
-		}
+			while(it != itEnd)
+			{
+				if(it->getdest() == pclass)
+				{
+					m_connected_slots.erase(it);
+					pclass->signal_disconnect(static_cast< _signal_base_interface* >(this));
+					return;
+				}
 
-		virtual has_slots_interface* getdest() const
-		{
-			return m_pobject;
+				++it;
+			}
 		}
 
 	private:
-		dest_type* m_pobject;
-		void (dest_type::* m_pmemfun)(arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, arg6_type);
-	};
-
-	template<class dest_type, class arg1_type, class arg2_type, class arg3_type,
-	class arg4_type, class arg5_type, class arg6_type, class arg7_type, class mt_policy>
-	class _connection7 : public _connection_base7<arg1_type, arg2_type,
-		arg3_type, arg4_type, arg5_type, arg6_type, arg7_type, mt_policy>
-	{
-	public:
-		_connection7()
+		static void do_slot_disconnect(_signal_base_interface* p, has_slots_interface* pslot)
 		{
-			m_pobject = NULL;
-			m_pmemfun = NULL;
-		}
+			_signal_base* const self = static_cast< _signal_base* >(p);
+			lock_block<mt_policy> lock(self);
+			connections_list::iterator it = self->m_connected_slots.begin();
+			connections_list::iterator itEnd = self->m_connected_slots.end();
 
-		_connection7(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
-			arg2_type, arg3_type, arg4_type, arg5_type, arg6_type, arg7_type))
-		{
-			m_pobject = pobject;
-			m_pmemfun = pmemfun;
-		}
+			while(it != itEnd)
+			{
+				connections_list::iterator itNext = it;
+				++itNext;
 
-		virtual ~_connection7()
-		{
-                }
+				if(it->getdest() == pslot)
+				{
+					self->m_connected_slots.erase(it);
+				}
 
-		virtual _connection_base7<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, arg6_type, arg7_type, mt_policy>* clone()
-		{
-			return new _connection7<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
-				arg5_type, arg6_type, arg7_type, mt_policy>(*this);
+				it = itNext;
+			}
 		}
 
-		virtual _connection_base7<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, arg6_type, arg7_type, mt_policy>* duplicate(has_slots_interface* pnewdest)
+		static void do_slot_duplicate(_signal_base_interface* p, const has_slots_interface* oldtarget, has_slots_interface* newtarget)
 		{
-			return new _connection7<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
-				arg5_type, arg6_type, arg7_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
-		}
+			_signal_base* const self = static_cast< _signal_base* >(p);
+			lock_block<mt_policy> lock(self);
+			connections_list::iterator it = self->m_connected_slots.begin();
+			connections_list::iterator itEnd = self->m_connected_slots.end();
 
-		virtual void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
-			arg5_type a5, arg6_type a6, arg7_type a7)
-		{
-			(m_pobject->*m_pmemfun)(a1, a2, a3, a4, a5, a6, a7);
-		}
+			while(it != itEnd)
+			{
+				if(it->getdest() == oldtarget)
+				{
+					self->m_connected_slots.push_back(it->duplicate(newtarget));
+				}
 
-		virtual has_slots_interface* getdest() const
-		{
-			return m_pobject;
+				++it;
+			}
 		}
 
-	private:
-		dest_type* m_pobject;
-		void (dest_type::* m_pmemfun)(arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, arg6_type, arg7_type);
+	protected:
+		connections_list m_connected_slots;
 	};
 
-	template<class dest_type, class arg1_type, class arg2_type, class arg3_type,
-	class arg4_type, class arg5_type, class arg6_type, class arg7_type,
-	class arg8_type, class mt_policy>
-	class _connection8 : public _connection_base8<arg1_type, arg2_type,
-		arg3_type, arg4_type, arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>
+	template<class mt_policy = SIGSLOT_DEFAULT_MT_POLICY>
+	class has_slots : public has_slots_interface, public mt_policy
 	{
+	private:
+		typedef std::set< _signal_base_interface* > sender_set;
+		typedef sender_set::const_iterator const_iterator;
+
 	public:
-		_connection8()
+		has_slots() : has_slots_interface(&has_slots::do_signal_connect, &has_slots::do_signal_disconnect, &has_slots::do_disconnect_all)
 		{
-			m_pobject = NULL;
-			m_pmemfun = NULL;
 		}
 
-		_connection8(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
-			arg2_type, arg3_type, arg4_type, arg5_type, arg6_type,
-			arg7_type, arg8_type))
+		~has_slots()
 		{
-			m_pobject = pobject;
-			m_pmemfun = pmemfun;
+			this->disconnect_all();
 		}
 
-		virtual ~_connection8()
-		{
-                }
+	private:
+		has_slots(has_slots const&);
+		has_slots& operator= (has_slots const&);
 
-		virtual _connection_base8<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>* clone()
+		static void do_signal_connect(has_slots_interface* p, _signal_base_interface* sender)
 		{
-			return new _connection8<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
-				arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>(*this);
+			has_slots* const self = static_cast< has_slots* >(p);
+			lock_block<mt_policy> lock(self);
+			self->m_senders.insert(sender);
 		}
 
-		virtual _connection_base8<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>* duplicate(has_slots_interface* pnewdest)
+		static void do_signal_disconnect(has_slots_interface* p, _signal_base_interface* sender)
 		{
-			return new _connection8<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
-				arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
+			has_slots* const self = static_cast< has_slots* >(p);
+			lock_block<mt_policy> lock(self);
+			self->m_senders.erase(sender);
 		}
 
-		virtual void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
-			arg5_type a5, arg6_type a6, arg7_type a7, arg8_type a8)
+		static void do_disconnect_all(has_slots_interface* p)
 		{
-			(m_pobject->*m_pmemfun)(a1, a2, a3, a4, a5, a6, a7, a8);
-		}
+			has_slots* const self = static_cast< has_slots* >(p);
+			lock_block<mt_policy> lock(self);
+			while (!self->m_senders.empty())
+			{
+				std::set< _signal_base_interface* > senders;
+				senders.swap(self->m_senders);
+				const_iterator it = senders.begin();
+				const_iterator itEnd = senders.end();
 
-		virtual has_slots_interface* getdest() const
-		{
-			return m_pobject;
+				while(it != itEnd)
+				{
+					_signal_base_interface* s = *it;
+					++it;
+					s->slot_disconnect(p);
+				}
+			}
 		}
 
 	private:
-		dest_type* m_pobject;
-		void (dest_type::* m_pmemfun)(arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, arg6_type, arg7_type, arg8_type);
+		sender_set m_senders;
 	};
 
+
 	template<class mt_policy = SIGSLOT_DEFAULT_MT_POLICY>
-	class signal0 : public _signal_base0<mt_policy>
+	class signal0 : public _signal_base<mt_policy>
 	{
-	public:
-		typedef _signal_base0<mt_policy> base;
+	private:
+		typedef _signal_base<mt_policy> base;
+
+	protected:
 		typedef typename base::connections_list connections_list;
-		using base::m_connected_slots;
 
+	public:
 		signal0()
 		{
-			;
-		}
-
-		signal0(const signal0<mt_policy>& s)
-			: _signal_base0<mt_policy>(s)
-		{
-			;
 		}
 
 		template<class desttype>
-			void connect(desttype* pclass, void (desttype::*pmemfun)())
+		void connect(desttype* pclass, void (desttype::*pmemfun)())
 		{
 			lock_block<mt_policy> lock(this);
-			_connection0<desttype, mt_policy>* conn =
-				new _connection0<desttype, mt_policy>(pclass, pmemfun);
-			m_connected_slots.push_back(conn);
-			pclass->signal_connect(this);
+			this->m_connected_slots.push_back(_opaque_connection(pclass, pmemfun));
+			pclass->signal_connect(static_cast< _signal_base_interface* >(this));
 		}
 
 		void emit()
 		{
 			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
+			typename connections_list::const_iterator it = this->m_connected_slots.begin();
+			typename connections_list::const_iterator itEnd = this->m_connected_slots.end();
 
 			while(it != itEnd)
 			{
-				itNext = it;
-				++itNext;
-
-				(*it)->emit();
+				_opaque_connection const& conn = *it;
+				++it;
 
-				it = itNext;
+				conn.emit();
 			}
 		}
 
 		void operator()()
 		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				itNext = it;
-				++itNext;
-
-				(*it)->emit();
-
-				it = itNext;
-			}
+			emit();
 		}
 	};
 
 	template<class arg1_type, class mt_policy = SIGSLOT_DEFAULT_MT_POLICY>
-	class signal1 : public _signal_base1<arg1_type, mt_policy>
+	class signal1 : public _signal_base<mt_policy>
 	{
-	public:
-		typedef _signal_base1<arg1_type, mt_policy> base;
+	private:
+		typedef _signal_base<mt_policy> base;
+
+	protected:
 		typedef typename base::connections_list connections_list;
-		using base::m_connected_slots;
 
+	public:
 		signal1()
 		{
-			;
-		}
-
-		signal1(const signal1<arg1_type, mt_policy>& s)
-			: _signal_base1<arg1_type, mt_policy>(s)
-		{
-			;
 		}
 
 		template<class desttype>
-			void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type))
+		void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type))
 		{
 			lock_block<mt_policy> lock(this);
-			_connection1<desttype, arg1_type, mt_policy>* conn =
-				new _connection1<desttype, arg1_type, mt_policy>(pclass, pmemfun);
-			m_connected_slots.push_back(conn);
-			pclass->signal_connect(this);
+			this->m_connected_slots.push_back(_opaque_connection(pclass, pmemfun));
+			pclass->signal_connect(static_cast< _signal_base_interface* >(this));
 		}
 
 		void emit(arg1_type a1)
 		{
 			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
+			typename connections_list::const_iterator it = this->m_connected_slots.begin();
+			typename connections_list::const_iterator itEnd = this->m_connected_slots.end();
 
 			while(it != itEnd)
 			{
-				itNext = it;
-				++itNext;
-
-				(*it)->emit(a1);
+				_opaque_connection const& conn = *it;
+				++it;
 
-				it = itNext;
+				conn.emit<arg1_type>(a1);
 			}
 		}
 
 		void operator()(arg1_type a1)
 		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				itNext = it;
-				++itNext;
-
-				(*it)->emit(a1);
-
-				it = itNext;
-			}
+			emit(a1);
 		}
 	};
 
 	template<class arg1_type, class arg2_type, class mt_policy = SIGSLOT_DEFAULT_MT_POLICY>
-	class signal2 : public _signal_base2<arg1_type, arg2_type, mt_policy>
+	class signal2 : public _signal_base<mt_policy>
 	{
-	public:
-		typedef _signal_base2<arg1_type, arg2_type, mt_policy> base;
+	private:
+		typedef _signal_base<mt_policy> base;
+
+	protected:
 		typedef typename base::connections_list connections_list;
-		using base::m_connected_slots;
 
+	public:
 		signal2()
 		{
-			;
-		}
-
-		signal2(const signal2<arg1_type, arg2_type, mt_policy>& s)
-			: _signal_base2<arg1_type, arg2_type, mt_policy>(s)
-		{
-			;
 		}
 
 		template<class desttype>
-			void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
+		void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
 			arg2_type))
 		{
 			lock_block<mt_policy> lock(this);
-			_connection2<desttype, arg1_type, arg2_type, mt_policy>* conn = new
-				_connection2<desttype, arg1_type, arg2_type, mt_policy>(pclass, pmemfun);
-			m_connected_slots.push_back(conn);
-			pclass->signal_connect(this);
+			this->m_connected_slots.push_back(_opaque_connection(pclass, pmemfun));
+			pclass->signal_connect(static_cast< _signal_base_interface* >(this));
 		}
 
 		void emit(arg1_type a1, arg2_type a2)
 		{
 			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
+			typename connections_list::const_iterator it = this->m_connected_slots.begin();
+			typename connections_list::const_iterator itEnd = this->m_connected_slots.end();
 
 			while(it != itEnd)
 			{
-				itNext = it;
-				++itNext;
-
-				(*it)->emit(a1, a2);
+				_opaque_connection const& conn = *it;
+				++it;
 
-				it = itNext;
+				conn.emit<arg1_type, arg2_type>(a1, a2);
 			}
 		}
 
 		void operator()(arg1_type a1, arg2_type a2)
 		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				itNext = it;
-				++itNext;
-
-				(*it)->emit(a1, a2);
-
-				it = itNext;
-			}
+			emit(a1, a2);
 		}
 	};
 
 	template<class arg1_type, class arg2_type, class arg3_type, class mt_policy = SIGSLOT_DEFAULT_MT_POLICY>
-	class signal3 : public _signal_base3<arg1_type, arg2_type, arg3_type, mt_policy>
+	class signal3 : public _signal_base<mt_policy>
 	{
-	public:
-		typedef _signal_base3<arg1_type, arg2_type, arg3_type, mt_policy> base;
+	private:
+		typedef _signal_base<mt_policy> base;
+
+	protected:
 		typedef typename base::connections_list connections_list;
-		using base::m_connected_slots;
 
+	public:
 		signal3()
 		{
-			;
-		}
-
-		signal3(const signal3<arg1_type, arg2_type, arg3_type, mt_policy>& s)
-			: _signal_base3<arg1_type, arg2_type, arg3_type, mt_policy>(s)
-		{
-			;
 		}
 
 		template<class desttype>
-			void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
+		void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
 			arg2_type, arg3_type))
 		{
 			lock_block<mt_policy> lock(this);
-			_connection3<desttype, arg1_type, arg2_type, arg3_type, mt_policy>* conn =
-				new _connection3<desttype, arg1_type, arg2_type, arg3_type, mt_policy>(pclass,
-				pmemfun);
-			m_connected_slots.push_back(conn);
-			pclass->signal_connect(this);
+			this->m_connected_slots.push_back(_opaque_connection(pclass, pmemfun));
+			pclass->signal_connect(static_cast< _signal_base_interface* >(this));
 		}
 
 		void emit(arg1_type a1, arg2_type a2, arg3_type a3)
 		{
 			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
+			typename connections_list::const_iterator it = this->m_connected_slots.begin();
+			typename connections_list::const_iterator itEnd = this->m_connected_slots.end();
 
 			while(it != itEnd)
 			{
-				itNext = it;
-				++itNext;
-
-				(*it)->emit(a1, a2, a3);
+				_opaque_connection const& conn = *it;
+				++it;
 
-				it = itNext;
+				conn.emit<arg1_type, arg2_type, arg3_type>(a1, a2, a3);
 			}
 		}
 
 		void operator()(arg1_type a1, arg2_type a2, arg3_type a3)
 		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				itNext = it;
-				++itNext;
-
-				(*it)->emit(a1, a2, a3);
-
-				it = itNext;
-			}
+			emit(a1, a2, a3);
 		}
 	};
 
 	template<class arg1_type, class arg2_type, class arg3_type, class arg4_type, class mt_policy = SIGSLOT_DEFAULT_MT_POLICY>
-	class signal4 : public _signal_base4<arg1_type, arg2_type, arg3_type,
-		arg4_type, mt_policy>
+	class signal4 : public _signal_base<mt_policy>
 	{
-	public:
-		typedef _signal_base4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy> base;
+	private:
+		typedef _signal_base<mt_policy> base;
+
+	protected:
 		typedef typename base::connections_list connections_list;
-		using base::m_connected_slots;
 
+	public:
 		signal4()
 		{
-			;
-		}
-
-		signal4(const signal4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>& s)
-			: _signal_base4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>(s)
-		{
-			;
 		}
 
 		template<class desttype>
-			void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
+		void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
 			arg2_type, arg3_type, arg4_type))
 		{
 			lock_block<mt_policy> lock(this);
-			_connection4<desttype, arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>*
-				conn = new _connection4<desttype, arg1_type, arg2_type, arg3_type,
-				arg4_type, mt_policy>(pclass, pmemfun);
-			m_connected_slots.push_back(conn);
-			pclass->signal_connect(this);
+			this->m_connected_slots.push_back(_opaque_connection(pclass, pmemfun));
+			pclass->signal_connect(static_cast< _signal_base_interface* >(this));
 		}
 
 		void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4)
 		{
 			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
+			typename connections_list::const_iterator it = this->m_connected_slots.begin();
+			typename connections_list::const_iterator itEnd = this->m_connected_slots.end();
 
 			while(it != itEnd)
 			{
-				itNext = it;
-				++itNext;
-
-				(*it)->emit(a1, a2, a3, a4);
+				_opaque_connection const& conn = *it;
+				++it;
 
-				it = itNext;
+				conn.emit<arg1_type, arg2_type, arg3_type, arg4_type>(a1, a2, a3, a4);
 			}
 		}
 
 		void operator()(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4)
 		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				itNext = it;
-				++itNext;
-
-				(*it)->emit(a1, a2, a3, a4);
-
-				it = itNext;
-			}
+			emit(a1, a2, a3, a4);
 		}
 	};
 
 	template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 	class arg5_type, class mt_policy = SIGSLOT_DEFAULT_MT_POLICY>
-	class signal5 : public _signal_base5<arg1_type, arg2_type, arg3_type,
-		arg4_type, arg5_type, mt_policy>
+	class signal5 : public _signal_base<mt_policy>
 	{
-	public:
-		typedef _signal_base5<arg1_type, arg2_type, arg3_type, arg4_type, arg5_type, mt_policy> base;
+	private:
+		typedef _signal_base<mt_policy> base;
+
+	protected:
 		typedef typename base::connections_list connections_list;
-		using base::m_connected_slots;
 
+	public:
 		signal5()
 		{
-			;
-		}
-
-		signal5(const signal5<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, mt_policy>& s)
-			: _signal_base5<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, mt_policy>(s)
-		{
-			;
 		}
 
 		template<class desttype>
-			void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
+		void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
 			arg2_type, arg3_type, arg4_type, arg5_type))
 		{
 			lock_block<mt_policy> lock(this);
-			_connection5<desttype, arg1_type, arg2_type, arg3_type, arg4_type,
-				arg5_type, mt_policy>* conn = new _connection5<desttype, arg1_type, arg2_type,
-				arg3_type, arg4_type, arg5_type, mt_policy>(pclass, pmemfun);
-			m_connected_slots.push_back(conn);
-			pclass->signal_connect(this);
+			this->m_connected_slots.push_back(_opaque_connection(pclass, pmemfun));
+			pclass->signal_connect(static_cast< _signal_base_interface* >(this));
 		}
 
 		void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
 			arg5_type a5)
 		{
 			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
+			typename connections_list::const_iterator it = this->m_connected_slots.begin();
+			typename connections_list::const_iterator itEnd = this->m_connected_slots.end();
 
 			while(it != itEnd)
 			{
-				itNext = it;
-				++itNext;
-
-				(*it)->emit(a1, a2, a3, a4, a5);
+				_opaque_connection const& conn = *it;
+				++it;
 
-				it = itNext;
+				conn.emit<arg1_type, arg2_type, arg3_type, arg4_type, arg5_type>(a1, a2, a3, a4, a5);
 			}
 		}
 
 		void operator()(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
 			arg5_type a5)
 		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				itNext = it;
-				++itNext;
-
-				(*it)->emit(a1, a2, a3, a4, a5);
-
-				it = itNext;
-			}
+			emit(a1, a2, a3, a4, a5);
 		}
 	};
 
 
 	template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 	class arg5_type, class arg6_type, class mt_policy = SIGSLOT_DEFAULT_MT_POLICY>
-	class signal6 : public _signal_base6<arg1_type, arg2_type, arg3_type,
-		arg4_type, arg5_type, arg6_type, mt_policy>
+	class signal6 : public _signal_base<mt_policy>
 	{
-	public:
-		typedef _signal_base6<arg1_type, arg2_type, arg3_type, arg4_type, arg5_type, arg6_type, mt_policy> base;
+	private:
+		typedef _signal_base<mt_policy> base;
+
+	protected:
 		typedef typename base::connections_list connections_list;
-		using base::m_connected_slots;
 
+	public:
 		signal6()
 		{
-			;
-		}
-
-		signal6(const signal6<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, arg6_type, mt_policy>& s)
-			: _signal_base6<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, arg6_type, mt_policy>(s)
-		{
-			;
 		}
 
 		template<class desttype>
-			void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
+		void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
 			arg2_type, arg3_type, arg4_type, arg5_type, arg6_type))
 		{
 			lock_block<mt_policy> lock(this);
-			_connection6<desttype, arg1_type, arg2_type, arg3_type, arg4_type,
-				arg5_type, arg6_type, mt_policy>* conn =
-				new _connection6<desttype, arg1_type, arg2_type, arg3_type,
-				arg4_type, arg5_type, arg6_type, mt_policy>(pclass, pmemfun);
-			m_connected_slots.push_back(conn);
-			pclass->signal_connect(this);
+			this->m_connected_slots.push_back(_opaque_connection(pclass, pmemfun));
+			pclass->signal_connect(static_cast< _signal_base_interface* >(this));
 		}
 
 		void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
 			arg5_type a5, arg6_type a6)
 		{
 			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
+			typename connections_list::const_iterator it = this->m_connected_slots.begin();
+			typename connections_list::const_iterator itEnd = this->m_connected_slots.end();
 
 			while(it != itEnd)
 			{
-				itNext = it;
-				++itNext;
-
-				(*it)->emit(a1, a2, a3, a4, a5, a6);
+				_opaque_connection const& conn = *it;
+				++it;
 
-				it = itNext;
+				conn.emit<arg1_type, arg2_type, arg3_type, arg4_type, arg5_type, arg6_type>(a1, a2, a3, a4, a5, a6);
 			}
 		}
 
 		void operator()(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
 			arg5_type a5, arg6_type a6)
 		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				itNext = it;
-				++itNext;
-
-				(*it)->emit(a1, a2, a3, a4, a5, a6);
-
-				it = itNext;
-			}
+			emit(a1, a2, a3, a4, a5, a6);
 		}
 	};
 
 	template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 	class arg5_type, class arg6_type, class arg7_type, class mt_policy = SIGSLOT_DEFAULT_MT_POLICY>
-	class signal7 : public _signal_base7<arg1_type, arg2_type, arg3_type,
-		arg4_type, arg5_type, arg6_type, arg7_type, mt_policy>
+	class signal7 : public _signal_base<mt_policy>
 	{
-	public:
-		typedef _signal_base7<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, arg6_type, arg7_type, mt_policy> base;
+	private:
+		typedef _signal_base<mt_policy> base;
+
+	protected:
 		typedef typename base::connections_list connections_list;
-		using base::m_connected_slots;
 
+	public:
 		signal7()
 		{
-			;
-		}
-
-		signal7(const signal7<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, arg6_type, arg7_type, mt_policy>& s)
-			: _signal_base7<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, arg6_type, arg7_type, mt_policy>(s)
-		{
-			;
 		}
 
 		template<class desttype>
-			void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
+		void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
 			arg2_type, arg3_type, arg4_type, arg5_type, arg6_type,
 			arg7_type))
 		{
 			lock_block<mt_policy> lock(this);
-			_connection7<desttype, arg1_type, arg2_type, arg3_type, arg4_type,
-				arg5_type, arg6_type, arg7_type, mt_policy>* conn =
-				new _connection7<desttype, arg1_type, arg2_type, arg3_type,
-				arg4_type, arg5_type, arg6_type, arg7_type, mt_policy>(pclass, pmemfun);
-			m_connected_slots.push_back(conn);
-			pclass->signal_connect(this);
+			this->m_connected_slots.push_back(_opaque_connection(pclass, pmemfun));
+			pclass->signal_connect(static_cast< _signal_base_interface* >(this));
 		}
 
 		void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
 			arg5_type a5, arg6_type a6, arg7_type a7)
 		{
 			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
+			typename connections_list::const_iterator it = this->m_connected_slots.begin();
+			typename connections_list::const_iterator itEnd = this->m_connected_slots.end();
 
 			while(it != itEnd)
 			{
-				itNext = it;
-				++itNext;
-
-				(*it)->emit(a1, a2, a3, a4, a5, a6, a7);
+				_opaque_connection const& conn = *it;
+				++it;
 
-				it = itNext;
+				conn.emit<arg1_type, arg2_type, arg3_type, arg4_type, arg5_type, arg6_type, arg7_type>(a1, a2, a3, a4, a5, a6, a7);
 			}
 		}
 
 		void operator()(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
 			arg5_type a5, arg6_type a6, arg7_type a7)
 		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				itNext = it;
-				++itNext;
-
-				(*it)->emit(a1, a2, a3, a4, a5, a6, a7);
-
-				it = itNext;
-			}
+			emit(a1, a2, a3, a4, a5, a6, a7);
 		}
 	};
 
 	template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 	class arg5_type, class arg6_type, class arg7_type, class arg8_type, class mt_policy = SIGSLOT_DEFAULT_MT_POLICY>
-	class signal8 : public _signal_base8<arg1_type, arg2_type, arg3_type,
-		arg4_type, arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>
+	class signal8 : public _signal_base<mt_policy>
 	{
-	public:
-		typedef _signal_base8<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, arg6_type, arg7_type, arg8_type, mt_policy> base;
+	private:
+		typedef _signal_base<mt_policy> base;
+
+	protected:
 		typedef typename base::connections_list connections_list;
-		using base::m_connected_slots;
 
+	public:
 		signal8()
 		{
-			;
-		}
-
-		signal8(const signal8<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>& s)
-			: _signal_base8<arg1_type, arg2_type, arg3_type, arg4_type,
-			arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>(s)
-		{
-			;
 		}
 
 		template<class desttype>
-			void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
+		void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
 			arg2_type, arg3_type, arg4_type, arg5_type, arg6_type,
 			arg7_type, arg8_type))
 		{
 			lock_block<mt_policy> lock(this);
-			_connection8<desttype, arg1_type, arg2_type, arg3_type, arg4_type,
-				arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>* conn =
-				new _connection8<desttype, arg1_type, arg2_type, arg3_type,
-				arg4_type, arg5_type, arg6_type, arg7_type,
-				arg8_type, mt_policy>(pclass, pmemfun);
-			m_connected_slots.push_back(conn);
-			pclass->signal_connect(this);
+			this->m_connected_slots.push_back(_opaque_connection(pclass, pmemfun));
+			pclass->signal_connect(static_cast< _signal_base_interface* >(this));
 		}
 
 		void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
 			arg5_type a5, arg6_type a6, arg7_type a7, arg8_type a8)
 		{
 			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
+			typename connections_list::const_iterator it = this->m_connected_slots.begin();
+			typename connections_list::const_iterator itEnd = this->m_connected_slots.end();
 
 			while(it != itEnd)
 			{
-				itNext = it;
-				++itNext;
-
-				(*it)->emit(a1, a2, a3, a4, a5, a6, a7, a8);
+				_opaque_connection const& conn = *it;
+				++it;
 
-				it = itNext;
+				conn.emit<arg1_type, arg2_type, arg3_type, arg4_type, arg5_type, arg6_type, arg7_type, arg8_type>(a1, a2, a3, a4, a5, a6, a7, a8);
 			}
 		}
 
 		void operator()(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
 			arg5_type a5, arg6_type a6, arg7_type a7, arg8_type a8)
 		{
-			lock_block<mt_policy> lock(this);
-			typename connections_list::const_iterator itNext, it = m_connected_slots.begin();
-			typename connections_list::const_iterator itEnd = m_connected_slots.end();
-
-			while(it != itEnd)
-			{
-				itNext = it;
-				++itNext;
-
-				(*it)->emit(a1, a2, a3, a4, a5, a6, a7, a8);
-
-				it = itNext;
-			}
+			emit(a1, a2, a3, a4, a5, a6, a7, a8);
 		}
 	};
 
-}; // namespace sigslot
+} // namespace sigslot
 
 #endif // WEBRTC_BASE_SIGSLOT_H__
Index: webrtc/src/webrtc/base/sigslot.cc
===================================================================
--- webrtc.orig/src/webrtc/base/sigslot.cc	2017-01-12 16:02:41.901491323 +0300
+++ webrtc/src/webrtc/base/sigslot.cc	2017-01-12 16:02:41.899491332 +0300
@@ -12,43 +12,8 @@ namespace sigslot {
 
 #ifdef _SIGSLOT_HAS_POSIX_THREADS
 
-multi_threaded_global::multi_threaded_global() {
-  pthread_mutex_init(get_mutex(), NULL);
-}
-
-multi_threaded_global::multi_threaded_global(const multi_threaded_global&) {
-}
-
-multi_threaded_global::~multi_threaded_global() = default;
-
-void multi_threaded_global::lock() {
-  pthread_mutex_lock(get_mutex());
-}
-
-void multi_threaded_global::unlock() {
-  pthread_mutex_unlock(get_mutex());
-}
-
-multi_threaded_local::multi_threaded_local() {
-  pthread_mutex_init(&m_mutex, NULL);
-}
-
-multi_threaded_local::multi_threaded_local(const multi_threaded_local&) {
-  pthread_mutex_init(&m_mutex, NULL);
-}
-
-multi_threaded_local::~multi_threaded_local() {
-  pthread_mutex_destroy(&m_mutex);
-}
-
-void multi_threaded_local::lock() {
-  pthread_mutex_lock(&m_mutex);
-}
-
-void multi_threaded_local::unlock() {
-  pthread_mutex_unlock(&m_mutex);
-}
+pthread_mutex_t multi_threaded_global::g_mutex = PTHREAD_MUTEX_INITIALIZER;
 
 #endif  // _SIGSLOT_HAS_POSIX_THREADS
 
-};  // namespace sigslot
+}  // namespace sigslot
